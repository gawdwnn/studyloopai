import type * as schema from "@/db/schema";
import {
	documentChunks,
	flashcards,
	generationConfigs,
	goldenNotes,
	multipleChoiceQuestions,
	openQuestions,
	summaries,
} from "@/db/schema";
import { type ExtractTablesWithRelations, count, eq, inArray } from "drizzle-orm";
import type { PgTransaction } from "drizzle-orm/pg-core";
import type { PostgresJsQueryResultHKT } from "drizzle-orm/postgres-js";

type DbTransaction = PgTransaction<
	PostgresJsQueryResultHKT,
	typeof schema,
	ExtractTablesWithRelations<typeof schema>
>;

export interface AiContentDeletionCounts {
	flashcards: number;
	mcqs: number;
	openQuestions: number;
	summaries: number;
	goldenNotes: number;
	total: number;
}

export interface ContentDeletionResult {
	configsDeleted: number;
	aiContentDeleted: AiContentDeletionCounts;
	chunksDeleted: number;
}

/**
 * AI content are generated by all materials associated to a given weekId not per material, hence this target should be weekId
 * on every aicontent table materialId is set to null
 * all implementations here needs to be updated to target weekId instead of materialId
 */

/**
 * Get counts of AI content and related data for given material IDs
 */
export async function getAiContentCounts(
	tx: DbTransaction,
	materialIds: string[]
): Promise<{
	configsCount: number;
	aiContentCounts: AiContentDeletionCounts;
	chunksCount: number;
}> {
	if (materialIds.length === 0) {
		return {
			configsCount: 0,
			aiContentCounts: {
				flashcards: 0,
				mcqs: 0,
				openQuestions: 0,
				summaries: 0,
				goldenNotes: 0,
				total: 0,
			},
			chunksCount: 0,
		};
	}

	const [configsCountResult, aiContentCountsResult, chunksCountResult] = await Promise.all([
		// Generation configs count
		tx
			.select({ count: count() })
			.from(generationConfigs)
			.where(inArray(generationConfigs.materialId, materialIds)),

		// AI content counts
		Promise.all([
			tx
				.select({ count: count() })
				.from(flashcards)
				.where(inArray(flashcards.materialId, materialIds)),
			tx
				.select({ count: count() })
				.from(multipleChoiceQuestions)
				.where(inArray(multipleChoiceQuestions.materialId, materialIds)),
			tx
				.select({ count: count() })
				.from(openQuestions)
				.where(inArray(openQuestions.materialId, materialIds)),
			tx
				.select({ count: count() })
				.from(summaries)
				.where(inArray(summaries.materialId, materialIds)),
			tx
				.select({ count: count() })
				.from(goldenNotes)
				.where(inArray(goldenNotes.materialId, materialIds)),
		]),

		// Document chunks count
		tx
			.select({ count: count() })
			.from(documentChunks)
			.where(inArray(documentChunks.materialId, materialIds)),
	]);

	const configsCount = configsCountResult[0]?.count || 0;
	const chunksCount = chunksCountResult[0]?.count || 0;

	const aiContentCounts = {
		flashcards: aiContentCountsResult[0]?.[0]?.count || 0,
		mcqs: aiContentCountsResult[1]?.[0]?.count || 0,
		openQuestions: aiContentCountsResult[2]?.[0]?.count || 0,
		summaries: aiContentCountsResult[3]?.[0]?.count || 0,
		goldenNotes: aiContentCountsResult[4]?.[0]?.count || 0,
		total: 0,
	};

	aiContentCounts.total = Object.values(aiContentCounts)
		.filter((_, index) => index < 5) // Exclude 'total' field
		.reduce((sum, count) => sum + count, 0);

	return {
		configsCount,
		aiContentCounts,
		chunksCount,
	};
}

/**
 * Delete all AI content and related data for given material IDs
 */
export async function deleteAiContentForMaterials(
	tx: DbTransaction,
	materialIds: string[]
): Promise<ContentDeletionResult> {
	if (materialIds.length === 0) {
		return {
			configsDeleted: 0,
			aiContentDeleted: {
				flashcards: 0,
				mcqs: 0,
				openQuestions: 0,
				summaries: 0,
				goldenNotes: 0,
				total: 0,
			},
			chunksDeleted: 0,
		};
	}

	// Get counts before deletion
	const { configsCount, aiContentCounts, chunksCount } = await getAiContentCounts(tx, materialIds);

	// Delete generation configs
	if (configsCount > 0) {
		await tx.delete(generationConfigs).where(inArray(generationConfigs.materialId, materialIds));
	}

	// Delete AI-generated content
	if (aiContentCounts.total > 0) {
		await Promise.all([
			aiContentCounts.flashcards > 0
				? tx.delete(flashcards).where(inArray(flashcards.materialId, materialIds))
				: Promise.resolve(),
			aiContentCounts.mcqs > 0
				? tx
						.delete(multipleChoiceQuestions)
						.where(inArray(multipleChoiceQuestions.materialId, materialIds))
				: Promise.resolve(),
			aiContentCounts.openQuestions > 0
				? tx.delete(openQuestions).where(inArray(openQuestions.materialId, materialIds))
				: Promise.resolve(),
			aiContentCounts.summaries > 0
				? tx.delete(summaries).where(inArray(summaries.materialId, materialIds))
				: Promise.resolve(),
			aiContentCounts.goldenNotes > 0
				? tx.delete(goldenNotes).where(inArray(goldenNotes.materialId, materialIds))
				: Promise.resolve(),
		]);
	}

	// Delete document chunks
	if (chunksCount > 0) {
		await tx.delete(documentChunks).where(inArray(documentChunks.materialId, materialIds));
	}

	return {
		configsDeleted: configsCount,
		aiContentDeleted: aiContentCounts,
		chunksDeleted: chunksCount,
	};
}

/**
 * Delete AI content for a single material ID
 */
export async function deleteAiContentForMaterial(
	tx: DbTransaction,
	materialId: string
): Promise<ContentDeletionResult> {
	return deleteAiContentForMaterials(tx, [materialId]);
}

/**
 * Get AI content counts for a single material ID
 */
export async function getAiContentCountsForMaterial(
	tx: DbTransaction,
	materialId: string
): Promise<{
	configsCount: number;
	aiContentCounts: AiContentDeletionCounts;
	chunksCount: number;
}> {
	const [configsCountResult, aiContentCountsResult, chunksCountResult] = await Promise.all([
		// Generation configs count
		tx
			.select({ count: count() })
			.from(generationConfigs)
			.where(eq(generationConfigs.materialId, materialId)),

		// AI content counts
		Promise.all([
			tx.select({ count: count() }).from(flashcards).where(eq(flashcards.materialId, materialId)),
			tx
				.select({ count: count() })
				.from(multipleChoiceQuestions)
				.where(eq(multipleChoiceQuestions.materialId, materialId)),
			tx
				.select({ count: count() })
				.from(openQuestions)
				.where(eq(openQuestions.materialId, materialId)),
			tx.select({ count: count() }).from(summaries).where(eq(summaries.materialId, materialId)),
			tx.select({ count: count() }).from(goldenNotes).where(eq(goldenNotes.materialId, materialId)),
		]),

		// Document chunks count
		tx
			.select({ count: count() })
			.from(documentChunks)
			.where(eq(documentChunks.materialId, materialId)),
	]);

	const configsCount = configsCountResult[0]?.count || 0;
	const chunksCount = chunksCountResult[0]?.count || 0;

	const aiContentCounts = {
		flashcards: aiContentCountsResult[0]?.[0]?.count || 0,
		mcqs: aiContentCountsResult[1]?.[0]?.count || 0,
		openQuestions: aiContentCountsResult[2]?.[0]?.count || 0,
		summaries: aiContentCountsResult[3]?.[0]?.count || 0,
		goldenNotes: aiContentCountsResult[4]?.[0]?.count || 0,
		total: 0,
	};

	aiContentCounts.total = Object.values(aiContentCounts)
		.filter((_, index) => index < 5) // Exclude 'total' field
		.reduce((sum, count) => sum + count, 0);

	return {
		configsCount,
		aiContentCounts,
		chunksCount,
	};
}
